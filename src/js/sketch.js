import p5 from 'p5';
export default function sketch(s) {
  let x, y, backgroundColor;

  const _windowWidth = window.innerWidth;
  const _windowHeight = window.innerHeight;

  const POPULATION_SIZE = 100;

  //raw file
  let dataFile = '../../resources/data/sugar.txt';
  //graph in the data file
  let graphData;

  let graph;
  let population;
  let results;
  let colors = new Array();
  let greedyColorsNumber = 0;
  let geneticColorsNumber = 0;
  let _canvas;
  let pivotPoint = {
    x: s.mouseX,
    y: s.mouseY
  }



  let drawMode = true;
  let skewMode = false;

  s.preload = () => {
    graphData = s.loadStrings('../gc/' + dataFile );
  }

  s.setup = () => {
    _canvas = s.createCanvas(_windowWidth, _windowHeight);
    graphData = graphData.toString().split(',');
    graph = new Graph();
    // graph.showInfo();
    graph.greedyColoring();     //it gives us the value max possible number of colors that we have to optimize
    greedyColorsNumber = colors.length;
    geneticColorsNumber = greedyColorsNumber;

    population = new Population();
    population.generate();

    population.showInfo();

    // console.log(colors);
    results = new Results();
  };

  s.mousePressed = () => {
    if (skewMode) {
      graph.assignSkew();
    } else {
      pivotPoint.x = s.mouseX;
      pivotPoint.y = s.mouseY;
    }
    skewMode = !skewMode;
  }

  s.draw = () => {
    //background gray color
    s.background(44, 44, 44);
    if (drawMode) {
      //draw lines between vertices
      graph.drawLines();
      //draw vertices on top of that
      graph.drawVertices();
    }
    //show the results
    results.show();
  }

  function Results() {
    //a component that is used just for displaying the current state of the results
    this.fontSize = 32;
    this.fontColor = s.color(220, 220, 220);
    this.position = s.createVector(5, this.fontSize);

    this.show = () => {
      s.textSize(this.fontSize);
      s.fill(this.fontColor);
      s.text('GREEDY ALGORITHM', this.position.x, this.position.y);
      s.text('Colors used: ' + greedyColorsNumber, this.position.x, this.position.y*2);

      s.text('GENETIC ALGORITHM', this.position.x, this.position.y*4);
      s.text('Colors used: ' + geneticColorsNumber, this.position.x, this.position.y*5);
    }
  }

  function Population() {
    this.size = POPULATION_SIZE;

    this.graphs = [];

    //for creating first generation
    this.generate = () => {
      //!! indexing from 1 !!
      for (let i=1; i<=this.size; i++) {
        this.graphs[i] = new Graph(i);
        this.graphs[i].randomize();
        this.graphs[i].mutationAlpha();
      }
    }

    this.showInfo = () => {
      this.graphs.forEach(graph => {
        console.log(graph);
      });
    }
  }

  function Graph(index = 0) {
    //index in the population
    this.index = index;
    //graph is made from vertices that are hold in this array
    this.vertices = [];

    //number of vertices
    this.size = parseInt(graphData[0], 10);

    //create vertices
    //!! INDEXING FROM 1 !!
    for (let i=1; i<=this.size; i++) {
      this.vertices[i] = new Vertex(i);
    }

    //assign vertices to their neighbors
    for (let i=1; i<graphData.length; i++) {
      let neighbors = graphData[i].split(' ');
      try {
        this.vertices[parseInt(neighbors[0])].relateNeighbors(parseInt(neighbors[1]));
        this.vertices[parseInt(neighbors[1])].relateNeighbors(parseInt(neighbors[0]));
      } catch (err) {
        console.log(neighbors);
        console.error(err);
      }
    }

    //when creating a population, assign random DNA to the graph
    this.randomize = () => {
      //for each vertex, give it a random color index from the current maximum range of colors
      //the current colors pool is generated by genetic algorithm
      this.vertices.forEach(vertex => {
        vertex.colorIndex = s.floor(s.random(greedyColorsNumber));
      });
    }

    //this mutation is applied to eliminate incorrect coloring.
    //there still is a chance that vertices will end up with incorrect coloring
    //however this steps adds variation that is needed for the population to evolve
    this.mutationAlpha = () => {
      this.vertices.forEach(vertex => {
        vertex.neighbors.forEach(neighbour => {
          if (vertex.colorIndex == this.vertices[neighbour].colorIndex) {
            //if neighbour has the same color, assign new color from the list of available colors
            vertex.colorIndex = s.floor(s.random(greedyColorsNumber));
          }
        });
      })
    }

    //FOR DEBUGGING
    this.showInfo = () => {
      this.vertices.forEach(vertex => {
        console.log(vertex);
      });
    }

    //draw the vertices of this graph
    this.drawVertices = () => {
      this.vertices.forEach(vertex => {
        vertex.show();
      });
    }

    //draw the lines between vertices that are neighbors
    this.drawLines = () => {
      this.vertices.forEach(vertex => {
        vertex.connectNeighbors();
      });
    }

    //greedy coloring algorithm
    this.greedyColoring = () => {
      this.vertices.forEach(vertex => {
        vertex.assignGreedyColor();
      });
    }

    //to set the new position values based on the skew
    this.assignSkew = () => {
      this.vertices.forEach(vertex => {
        let skewedPosition = vertex.calculatePosition();
        vertex.position.x = skewedPosition[0];
        vertex.position.y = skewedPosition[1];
      });
    }

    //counts the number of all colors used to color the graph
    this.numberOfColors = () => {
      let tmp = new Set();
      this.vertices.forEach(vertex => {
        tmp.add(vertex.colorIndex);
      });
      return tmp.size;
    }

    //counts the number of bad edges in the graph
    this.numberOfBadEdges = () => {
      let tmp = 0;
      this.vertices.forEach(vertex => {
        vertex.neighors.forEach(neighbour => {
          if (vertex.colorIndex == this.vertices[neighour].colorIndex) {
            tmp++;
          }
        });
      });
      //every edge is counted twice, so we divide it by half to get the actual number of bad edges
      return tmp/2;
    }

    //fitness value of the graph means how likely we are to pick this graph as a parent
    this.fitness = () => {
      return this.numberOfBadEdges * this.size + this.numberOfColors;
    }

  }

  function Vertex(index) {
    //number of the vertex in the graph
    this.index = index;

    //random multiplier used for skewing graph (when moving a mouse)
    this.multiplier = s.random(1);

    //center position of each vertex
    this.position = s.createVector(_windowWidth*0.2 + s.random(0.7)*_windowWidth, _windowHeight*0.1+s.random(0.8)*_windowHeight);



    //calculate the vertex center based on the mouse position on the screen
    this.calculatePosition = () => {
      let x = this.position.x + this.multiplier * (s.mouseX-pivotPoint.x);
      let y = this.position.y + this.multiplier * (s.mouseY-pivotPoint.y);
      return [x, y];
    }

    //set of all vertex's neighbors
    this.neighbors = new Set();

    this.radius = 25 + s.random(1)*10;

    //color index determines the value of color from the colors array (global)
    this.colorIndex = -1;

    //color of the edge
    this.lineColor = s.random(12);

    //function used for adding neighbors to the vertex
    this.relateNeighbors = (neighbourIndex) => {
      this.neighbors.add(neighbourIndex);
    }

    //draw vertex
    this.show = () => {
      s.push();
      s.noStroke();
      if (this.colorIndex != -1) {
        s.fill(colors[this.colorIndex]);
      }
      let skewedPosition = skewMode ? this.calculatePosition() : [this.position.x, this.position.y];
      s.ellipse(skewedPosition[0], skewedPosition[1], this.radius, this.radius);
      s.pop();
    }

    //draw lines between this vertex and its neighbors
    this.connectNeighbors = () => {
      this.neighbors.forEach(neighbourIndex => {
        s.push();
        s.stroke(this.lineColor);
        let skewedPositionA = skewMode ? this.calculatePosition() : [this.position.x, this.position.y];
        let skewedPositionB = skewMode ? graph.vertices[neighbourIndex].calculatePosition() : [graph.vertices[neighbourIndex].position.x, graph.vertices[neighbourIndex].position.y];
        s.line(skewedPositionA[0], skewedPositionA[1], skewedPositionB[0], skewedPositionB[1]);
        s.pop();
      });
    }

    //function to get a color for this vertex. it's assigned using greedy algorithm
    this.assignGreedyColor = () => {
      let alreadyUsed = new Set();
      this.neighbors.forEach(neighbour => {
        alreadyUsed.add(graph.vertices[neighbour].colorIndex);
      });
      for (let i=0; i<colors.length; i++) {
        if (alreadyUsed.has(i)) continue;
        else {
          //assign the color that already exists
          this.colorIndex = i;
          return;
        }
      }
      //create new color and push it to the colors array
      this.colorIndex = colors.length;
      colors.push(s.color(s.random(255), s.random(255), s.random(255)));
    }
  }

}
